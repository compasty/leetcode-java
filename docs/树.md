# 二叉树经典问题

1. Q543: 二叉树的直径

一句话解法：使用后序遍历
节点直径=左节点深度+右节点深度
节点深度=1+max(左节点深度，右节点深度)

2. Q104: 二叉树的最大深度

一句话解法：DFS

3. 路径总和

+ 3.1 Q112 路径总和: 判断是否存在满足targetSum的路径
一句话解法：使用DFS，核心代码 `left != null && hasPathSum(root.left, targetSum - root.val)`

+ 3.2 Q113 路径总和II: 

4. 二叉树的最近公共祖先

+ 4.1 二叉树的最近公共祖先：
+ 4.2 二叉树的最近公共祖先II:

5. 平衡二叉树

+ 5.1 是否平衡二叉树：

一句话解法：定义树的高度，表示到最深叶子节点的路径数
则有：`isBalanced(root) = isBalanced(root.left) && isBalanced(root.right) && Math.abs(height(root.left) - height(root.right)) <= 1`
注意：这里需要使用后序遍历，来提高执行效率

6. 二叉树的视图

7. 前序中序写后序，后序中序写后前序，二叉搜索树基于前序恢复

8. 二叉搜索树

8.1 二叉搜索树的最近节点查询

9. 完全二叉树

9.1 完全二叉树的节点数量


# 二叉搜索树的性质

# 完全二叉树的性质


# BFS经典代码结构

```Java

```

# DFS经典代码结构

```Java

private void dfs(TreeNode node, T info) {
    if (isLeaf(node)) {
        // 处理代码， 通常会计算一个全局的结果变量
        return;
    }
    if (node.left != null) {
        dfs(node.left, 更新info);
    }
    if (node.right != null) {
        dfs(node.right, 更新info);
    }
}
```

# 使用栈实现前序遍历

[参考](https://leetcode.cn/leetbook/read/dfs/eg58hi/)

```Java
public class Solution {

    private enum Action {
        /**
         * 如果当前结点有孩子结点（左右孩子结点至少存在一个），执行 GO
         */
        GO,
        /**
         * 添加到结果集（真正输出这个结点）
         */
        ADDTORESULT
    }

    private class Command {
        private Action action;
        private TreeNode node;

        /**
         * 将动作类与结点类封装起来
         *
         * @param action
         * @param node
         */
        public Command(Action action, TreeNode node) {
            this.action = action;
            this.node = node;
        }
    }

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        Deque<Command> stack = new ArrayDeque<>();
        stack.addLast(new Command(Action.GO, root));
        while (!stack.isEmpty()) {
            Command command = stack.removeLast();
            if (command.action == Action.ADDTORESULT) {
                res.add(command.node.val);
            } else {
                // 特别注意：以下的顺序与递归执行的顺序反着来，即：倒过来写的结果
                // 前序遍历：根结点、左子树、右子树、
                // 添加到栈的顺序：右子树、左子树、根结点
                if (command.node.right != null) {
                    stack.add(new Command(Action.GO, command.node.right));
                }
                if (command.node.left != null) {
                    stack.add(new Command(Action.GO, command.node.left));
                }
                stack.add(new Command(Action.ADDTORESULT, command.node));
            }
        }
        return res;
    }
}
```

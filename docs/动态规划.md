# 参考

1. 动态规划解题套路框架：https://labuladong.online/algo/essential-technique/dynamic-programming-framework-2/

# 基本方法
动态规划的核心是：base case + 状态转移放层 + 明确dp数组/函数的含义

> dp数组的核心是解决 **重叠子问题**

1. 什么是 **最优子结构** ? 无法通过子问题的最优值推出更大规模的问题的最优值，就不是最优子结构 => 调整子结构设计
2. 如何寻找遍历方向？ （a）遍历的过程中，所需的状态必须是已经计算出来的 (b) 遍历结束后，存储结果的那个位置必须已经被计算出来
3. 如何确定不合法索引的初始值？ 一般是根据求最大还是最小，确定一个相对不可能达到的小值 或者 大值

# 经典问题

## 子集划分

1. Q698:划分为k个相等的子集

## 单词拆分

1. Q139: 单词拆分
2. Q140: 单词拆分II


## 最小路径和

1. Q64: 最小路径和（只能向下或者向上）

一句话解法： (1)当i>0 且 j=0 时，`dp[i][0]=dp[i−1][0]+grid[i][0]` (2)当 i=0且j>0 时，`dp[0][j]=dp[0][j−1]+grid[0][j]`
(3) 当 i>0 且 j>0 时，`dp[i][j]=min(dp[i−1][j],dp[i][j−1])+grid[i][j]`

2. Q931: 下降路径最小和

一句话解法：`dp[i][j]`表示从第一行（`matrix[0][..]`）向下落，落到位置`matrix[i][j]`的最小路径和为`dp(matrix, i, j)`,
状态转移方程为 `dp(matrix, i, j) = matrix[i][j] + min(dp(matrix, i - 1, j), dp(matrix, i - 1, j - 1),  dp(matrix, i - 1, j + 1))`

## 两个字符串的动态规划问题

解决两个字符串的动态规划问题，一般都是用两个指针 i, j 分别指向两个字符串的最后，然后一步步往前移动，缩小问题的规模

1. 编辑距离
2. Q115: 不同的子序列
3. 

## 正则表达式匹配

1. Q10: 

## 背包问题及其变体

1. Q494

## 鸡蛋掉落问题

## 回文问题

1. 最长回文子串
2. Q516: 最长回文子序列
3. Q1312: 让字符串成为回文串的最少插入次数
4. 回文分割

## 打劫问题

## 石子游戏

## 零钱兑换

## 最长递增子序列

1. Q300. 最长递增子序列

一句话解法：dp数组表示以对应位置结尾的最长递增子序列，则有下面的转移方程：

```Java
for (int i = 0; i < nums.length; i++) {
    for (int j = 0; j < i; j++) {
        // 寻找 nums[0..j-1] 中比 nums[i] 小的元素
        if (nums[i] > nums[j]) {
            // 把 nums[i] 接在后面，即可形成长度为 dp[j] + 1，
            // 且以 nums[i] 为结尾的递增子序列
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
}
```

O(nlogn)算法：建立多个倒序的牌堆，新牌按照 搜索左侧边界的二分查找 找到对应的牌堆

2. Q354. 俄罗斯套娃信封问题

## 接雨水

## 股票买卖

1. Q121:
2. Q122:
3. Q123:
4. Q188:
5. Q309:
6. Q714: